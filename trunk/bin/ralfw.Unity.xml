<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<doc>
  <assembly>
    <name>ralfw.Unity</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator">
      <summary>
            Base interface for all extension configuration interfaces.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator.Container">
      <summary>
            Retrieve the container instance that we are currently configuring.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainerExtension">
      <summary>
            Base class for all <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> extension objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.InitializeExtension(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            The container calls this method when the extension is added.
            </summary>
      <param name="context">A <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> instance that gives the
            extension access to the internals of the container.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Initialize(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            Initial the container with this extension's functionality.
            </summary>
      <remarks>
            When overridden in a derived class, this method will modify the given
            <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> by adding strategies, policies, etc. to
            install it's functions into the container.</remarks>
      <param name="extensionContext">The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> to use to initialize the
            container.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Remove(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            Removes the extension's functions from the container.
            </summary>
      <remarks>
        <para>
            This method is called when extensions are being removed from the container. It can be
            used to do things like disconnect event handlers or clean up member state. You do not
            need to remove strategies or policies here; the container will do that automatically.
            </para>
        <para>
            The default implementation of this method does nothing.</para>
      </remarks>
      <param name="extensionContext">
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> to use to manipulate the
            underlying state of the container.
            </param>
    </member>
    <member name="P:Microsoft.Practices.Unity.UnityContainerExtension.Container">
      <summary>
            The container this extension has been added to.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> that this extension has been added to.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension">
      <summary>
            This extension installs the default strategies and policies into the container
            to implement the standard behavior of the Unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension.Initialize(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            Add the default ObjectBuilder strategies &amp; policies to the container.
            </summary>
      <param name="extensionContext">
        <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> used to manipulate the container state.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ExtensionContext">
      <summary>
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> class provides the means for extension objects
            to manipulate the internal state of the <see cref="T:Microsoft.Practices.Unity.UnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ExtensionContext.RegisterNamedType(System.Type,System.String)">
      <summary>
            Store a type/name pair for later resolution.
            </summary>
      <remarks>
        <para>
            When users register type mappings (or other things) with a named key, this method
            allows you to register that name with the container so that when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.GetAll``1" />
            method is called, that name is included in the list that is returned.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> to register.</param>
      <param name="name">Name assocated with that type.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Container">
      <summary>
            The container that this context is associated with.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Strategies">
      <summary>
            The strategies this container uses.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> that the container uses to build objects.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.BuildPlanStrategies">
      <summary>
            The strategies this container uses to construct build plans.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> that this container uses when creating
            build plans.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Policies">
      <summary>
            The policies this container uses.
            </summary>
      <remarks>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> the that container uses to build objects.</remarks>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Locator">
      <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" /> that this container uses.
            </summary>
      <value>The Locator is an object that is used to store information to be found later during the build process.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Lifetime">
      <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> that this container uses.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> is used to manage <see cref="T:System.IDisposable" /> objects that the container is managing.</value>
    </member>
    <member name="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringTypeMapping">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.UnityContainer.Register(System.Type,System.Type,System.String)" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="E:Microsoft.Practices.Unity.ExtensionContext.SettingSingleton">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.UnityContainer.SetSingleton(System.Type,System.String)" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.Object,System.String,System.Boolean)" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.NotPresentBehavior">
      <summary>
            This type defines what the container will do to fulfill a dependency that isn't
            already stored in the container.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.NotPresentBehavior.Build">
      <summary>
        <para>
            Create an instance of the dependency by asking the container to create it.
            </para>
        <para>
            This is the default.
            </para>
      </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.NotPresentBehavior.Null">
      <summary>
            Return null if the dependency isn't already present in the container.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.NotPresentBehavior.Throw">
      <summary>
            Throw an exception if the dependency is not available.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionConstructorAttribute">
      <summary>
            This attribute is used to indicate which constructor to choose when
            the container attempts to build a type.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.NamedEventArgs">
      <summary>
            An EventArgs class that holds a string Name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs" /> with a null name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor(System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs" /> with the given name.
            </summary>
      <param name="name">Name to store.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.NamedEventArgs.Name">
      <summary>
            The name.
            </summary>
      <value>Name used for this event arg object.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs">
      <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance" /> event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor">
      <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs" /> instance.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor(System.Type,System.Object,System.String,System.Boolean)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs" /> instance initialized with the given arguments.
            </summary>
      <param name="registeredType">Type of instance being registered.</param>
      <param name="instance">The instance object itself.</param>
      <param name="name">Name to register under, null if default registration.</param>
      <param name="containerControlsLifetime">If true, container will dispose <paramref name="instance" />
            at dispose time. If false, container will not dispose <paramref name="instance" />.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.RegisteredType">
      <summary>
            Type of instance being registered.
            </summary>
      <value>
            Type of instance being registered.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.Instance">
      <summary>
            Instance object being registered.
            </summary>
      <value>Instance object being registered</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.ContainerControlsLifetime">
      <summary>
            Should the container take over the lifetime of this object?
            </summary>
      <value>If true, then yes, otherwise no.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.IUnityContainer">
      <summary>
            Interface defining the behavior of the Unity dependency injection container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Register``2">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Register``2(System.String)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Register(System.Type,System.Type)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Register(System.Type,System.Type,System.String)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.SetSingleton``1">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
        <para>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </para>
        <para>
            This overload registers a default registration.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> being registered as a singleton.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.SetSingleton``1(System.String)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> being registered as a singleton.</typeparam>
      <param name="name">Name for registration (null if default registration).</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.SetSingleton(System.Type)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
        <para>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </para>
        <para>
            This overload registers a default registration.
            </para>
      </remarks>
      <param name="typeOfSingleton">
        <see cref="T:System.Type" /> being registered as a singleton.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.SetSingleton(System.Type,System.String)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </remarks>
      <param name="typeOfSingleton">
        <see cref="T:System.Type" /> being registered as a singleton.</param>
      <param name="name">Name for registration (null if default registration).</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0,System.String)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0,System.String,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object,System.String)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object,System.String,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Get``1">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Get``1(System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Get(System.Type)">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Get(System.Type,System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.GetAll``1">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <typeparam name="T">The type requested.</typeparam>
      <returns>Set of objects of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.GetAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddNewExtension``1">
      <summary>
            Creates a new extension object and adds it to the container.
            </summary>
      <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure``1">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <typeparam name="TConfigurator">The configuration interface required.</typeparam>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure(System.Type)">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionMethodAttribute">
      <summary>
            This attribute is used to mark methods that should be called when
            the container is building an object.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.Guard">
      <summary>
            A static helper class that includes various parameter checking routines.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNull(System.Object,System.String)">
      <summary>
            Throws <see cref="T:System.ArgumentNullException" /> if the given argument is null.
            </summary>
      <exception cref="T:System.ArgumentNullException"> if tested value if null.</exception>
      <param name="argumentValue">Argument value to test.</param>
      <param name="argumentName">Name of the argument being tested.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNullOrEmpty(System.String,System.String)">
      <summary>
            Throws an exception if the tested string argument is null or the empty string.
            </summary>
      <exception cref="T:System.ArgumentNullException">Thrown if string value is null.</exception>
      <exception cref="T:System.ArgumentException">Thrown if the string is empty</exception>
      <param name="argumentValue">Argument value to check.</param>
      <param name="argumentName">Name of argument being checked.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.TypeIsAssignable(System.Type,System.Type,System.String)">
      <summary>
            Verifies that an argument type is assignable from the provided type (meaning
            interfaces are implemented, or classes exist in the base class hierarchy).
            </summary>
      <param name="assignmentTargetType">The argument type that will be assigned to.</param>
      <param name="assignmentValueType">The type of the value being assigned.</param>
      <param name="argumentName">Argument name.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.Sequence">
      <summary>
            A series of helper methods to deal with sequences -
            objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <remarks>LINQ in C# 3.0 does pretty much the same stuff,
            but we're keeping C# 2.0 compatibility here.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ToList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Given an <see cref="T:System.Collections.Generic.IEnumerable`1" />, return a
            new <see cref="T:System.Collections.Generic.List`1" /> containing the same contents.
            </summary>
      <typeparam name="T">Type of item store in the sequence.</typeparam>
      <param name="seq">Sequence to create list from.</param>
      <returns>The new <see cref="T:System.Collections.Generic.List`1" /></returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey">
      <summary>
            Build key used to combine a type object with a string name. Used by
            ObjectBuilder to indicate exactly what is being built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.#ctor(System.Type,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance with the given
            type and name.
            </summary>
      <param name="type">
        <see cref="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Type" /> to build.</param>
      <param name="name">Key to use to look up type mappings and singletons.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.#ctor(System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance for the default
            buildup of the given type.
            </summary>
      <param name="type">
        <see cref="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Type" /> to build.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Make``1">
      <summary>
            This helper method creates a new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance. It is
            initialized for the default key for the given type.
            </summary>
      <typeparam name="T">Type to build.</typeparam>
      <returns>A new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Make``1(System.String)">
      <summary>
            This helper method creates a new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance for
            the given type and key.
            </summary>
      <typeparam name="T">Type to build</typeparam>
      <param name="name">Key to use to look up type mappings and singletons.</param>
      <returns>A new <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instance initialized with the given type and name.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Equals(System.Object)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type. Also, comparing
            against a different type will also return false.</remarks>
      <param name="obj">Object to compare to.</param>
      <returns>True if the two keys are equal, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.GetHashCode">
      <summary>
            Calculate a hash code for this instance.
            </summary>
      <returns>A hash code.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.op_Equality(Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey,Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances for equality.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type.</remarks>
      <param name="left">First of the two keys to compare.</param>
      <param name="right">Second of the two keys to compare.</param>
      <returns>True if the values of the keys are the same, else false.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.op_Inequality(Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey,Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances for inequality.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type. If either field differs
            the keys are not equal.</remarks>
      <param name="left">First of the two keys to compare.</param>
      <param name="right">Second of the two keys to compare.</param>
      <returns>false if the values of the keys are the same, else true.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.ToString">
      <summary>
            Formats the build key as a string (primarily for debugging).
            </summary>
      <returns>A readable string representation of the build key.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Type">
      <summary>
            Return the <see cref="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Type" /> stored in this build key.
            </summary>
      <value>The type to build.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeBuildKey.Name">
      <summary>
            Returns the name stored in this build key.
            </summary>
      <remarks>The name to use when building.</remarks>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension">
      <summary>
            This extension supplies the default behavior of the UnityContainer API
            by handling the context events and setting policies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Initialize(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            Install the default container behavior into the <paramref name="extensionContext" />.
            </summary>
      <param name="extensionContext">The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> used to manipulate the
            container's internal state.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Remove(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            Remove the default behavior from the <paramref name="extensionContext" />.
            </summary>
      <param name="extensionContext">The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> used to manipulate the
            container's internal state.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.OnRegister(System.Object,Microsoft.Practices.Unity.RegisterTypeMappingEventArgs)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <param name="sender">The container.</param>
      <param name="e">
        <see cref="T:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs" /> containing the type mapping
            information.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.OnRegisterInstance(System.Object,Microsoft.Practices.Unity.RegisterInstanceEventArgs)">
      <summary>
            Register an instance with the container.
            </summary>
      <param name="sender">The container.</param>
      <param name="e">
        <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs" /> containing the registration
            information.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.OnSetSingleton(System.Object,Microsoft.Practices.Unity.SetSingletonEventArgs)">
      <summary>
            Register a type as a singleton with the container.
            </summary>
      <param name="sender">The container.</param>
      <param name="e">
        <see cref="T:Microsoft.Practices.Unity.SetSingletonEventArgs" /> containing the registration information.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.ArgumentMustNotBeEmpty">
      <summary>
              Looks up a localized string similar to The provided string argument must not be empty.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.TypesAreNotAssignable">
      <summary>
              Looks up a localized string similar to The type {1} cannot be assigned to variables of type {0}.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage">
      <summary>
            The build stages we use in the Unity container
            strategy pipeline.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Setup">
      <summary>
            First stage. By default, nothing happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.TypeMapping">
      <summary>
            Second stage. Type mapping occurs here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Singleton">
      <summary>
            Third stage. Singletons and registered instances are checked here,
            and if they're available the rest of the pipeline is skipped.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PreCreation">
      <summary>
            Fourth stage. Reflection over constructors, properties, etc. is
            performed here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Creation">
      <summary>
            Fifth stage. Instance creation happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Initialization">
      <summary>
            Sixth stage. Property sets and method injection happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PostInitialization">
      <summary>
            Seventh and final stage. By default, nothing happens here.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainerBase">
      <summary>
            A base class for implmenting <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> that provides
            reasonable implementations for most of the overloads defined by the interface.
            The overloads all call down to the non-generic versions of the methods with
            the most parameters.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Register``2">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Register``2(System.String)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Register(System.Type,System.Type)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Register(System.Type,System.Type,System.String)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.SetSingleton``1">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
        <para>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </para>
        <para>
            This overload registers a default registration.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> being registered as a singleton.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.SetSingleton``1(System.String)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> being registered as a singleton.</typeparam>
      <param name="name">Name for registration (null if default registration).</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.SetSingleton(System.Type)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
        <para>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </para>
        <para>
            This overload registers a default registration.
            </para>
      </remarks>
      <param name="typeOfSingleton">
        <see cref="T:System.Type" /> being registered as a singleton.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.SetSingleton(System.Type,System.String)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </remarks>
      <param name="typeOfSingleton">
        <see cref="T:System.Type" /> being registered as a singleton.</param>
      <param name="name">Name for registration (null if default registration).</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0,System.String)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0,System.String,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object,System.String)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object,System.String,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Get``1">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Get``1(System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Get(System.Type)">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Get(System.Type,System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.GetAll``1">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <typeparam name="T">The type requested.</typeparam>
      <returns>Set of objects of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.GetAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddNewExtension``1">
      <summary>
            Creates a new extension object and adds it to the container.
            </summary>
      <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure``1">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <typeparam name="TConfigurator">The configuration interface required.</typeparam>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure(System.Type)">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Dispose">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.Unity.IUnityParentContainer">
      <summary>
            Unity containers that can be parents of other
            containers implement this interface.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityParentContainer.CreateChildContainer">
      <summary>
            Create a child container.
            </summary>
      <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
      <returns>The new child container.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainer">
      <summary>
            A simple, extensible dependency injection container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainer.ExtensionContextImpl">
      <summary>
            Implementation of the ExtensionContext that is actually used
            by the UnityContainer implementation.
            </summary>
      <remarks>
            This is a nested class so that it can access state in the
            container that would otherwise be inaccessible.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor">
      <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.UnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor(Microsoft.Practices.Unity.UnityContainer)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> with the given parent container.
            </summary>
      <param name="parent">The parent <see cref="T:Microsoft.Practices.Unity.UnityContainer" />. The current object
            will apply it's own settings first, and then check the parent for additional ones.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Register(System.Type,System.Type,System.String)">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.SetSingleton(System.Type,System.String)">
      <summary>
            Register a type as a singleton with the container, using the given key.
            </summary>
      <remarks>
            If a type is registered as a singleton, the first time an instance of that
            type (or type and name if registering with a name) is created, the instance
            will be stored by the container. Later requests for that type will return
            the same instance originally created.
            </remarks>
      <param name="typeOfSingleton">
        <see cref="T:System.Type" /> being registered as a singleton.</param>
      <param name="name">Name for registration (null if default registration).</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.Object,System.String,System.Boolean)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="containerControlsLifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Get(System.Type,System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.GetAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Configure(System.Type)">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.CreateChildContainer">
      <summary>
            Create a child container.
            </summary>
      <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
      <returns>The new child container.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose(System.Boolean)">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            This class doesn't have a finalizer, so <paramref name="disposing" /> will always be true.</remarks>
      <param name="disposing">True if being called from the IDisposable.Dispose
            method, false if being called from a finalizer.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs">
      <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringTypeMapping" />
            event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs" /> instance with null
            mapping information.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs.#ctor(System.Type,System.Type,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs" /> with the given type mappings.
            </summary>
      <param name="typeFrom">Source <see cref="T:System.Type" /> mapping.</param>
      <param name="typeTo">Destination <see cref="T:System.Type" /> mapping.</param>
      <param name="name">
        <para>
            Name used for the mapping.
            </para>
        <para>
            This will be null for the default mapping.
            </para>
      </param>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs.TypeFrom">
      <summary>
            Source type for this mapping.
            </summary>
      <value>Source type for this mapping.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterTypeMappingEventArgs.TypeTo">
      <summary>
            Destination type for the mapping.
            </summary>
      <value>Destination type for this mapping.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.DependencyAttribute">
      <summary>
            This attribute is used to mark properties and parameters as targets for injection.
            </summary>
      <remarks>
            For properties, this attribute is necessary for injection to happen. For parameters,
            it's not needed unless you want to specify additional information to control how
            the parameter is resolved.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute" /> with no key and default <see cref="F:Microsoft.Practices.Unity.NotPresentBehavior.Build" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor(System.String)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute" /> with the given key.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.GetNotPresentBehavior">
      <summary>
            Return an integer value that maps to the OB <see cref="T:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior" /> enum.
            </summary>
      <returns>The NotPresentBehavior value</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.EmitBuildKey(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,System.Type)">
      <summary>
            Using the given <paramref name="ilContext" />, emit code to load
            the appropriate build key onto the stack.
            </summary>
      <param name="ilContext">Context to write the IL to.</param>
      <param name="typeToBuild">Type included in the build key.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.DependencyAttribute.Key">
      <summary>
            The key specified in the constructor.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.DependencyAttribute.NotPresentBehavior">
      <summary>
            How to resolve the dependency.
            </summary>
      <value>By default, this is <see cref="F:Microsoft.Practices.Unity.NotPresentBehavior.Build" />, which means
            to run the dependency through the container. See <see cref="T:Microsoft.Practices.Unity.NotPresentBehavior" />
            for the other options.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.SetSingletonEventArgs">
      <summary>
            Event arguments class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.SettingSingleton" /> event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.SetSingletonEventArgs.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.SetSingletonEventArgs" /> instance with no type or name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.SetSingletonEventArgs.#ctor(System.Type,System.String)">
      <summary>
            Createa a new <see cref="T:Microsoft.Practices.Unity.SetSingletonEventArgs" /> instance with the given type and name.
            </summary>
      <param name="singletonType">Type that is being marked as a singleton.</param>
      <param name="name">Name for the registration. For a default registration this will be null.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.SetSingletonEventArgs.SingletonType">
      <summary>
            Type of singleton being registered.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy">
      <summary>
            Represents a strategy in the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />'s chain of responsibility.
            Strategies are required to support both BuildUp and TearDown. Although you
            can implement this interface directly, you may also choose to use
            <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> as the base class for your strategies, as
            this class provides useful helper methods and makes support BuildUp and TearDown
            optional.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.TearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Called during the chain of responsibility for a tear down operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="item">The item that is being torn down.</param>
      <returns>The torn down object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy">
      <summary>
            Represents a strategy in the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />'s chain of responsibility.
            Strategies are required to support both BuildUp and TearDown.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.GetTypeFromBuildKey(System.Object)">
      <summary>
            Gets the <see cref="T:System.Type" /> of object to build from the build key.
            </summary>
      <param name="buildKey">The build key to get the <see cref="T:System.Type" />.</param>
      <returns>The <see cref="T:System.Type" /> of object to build from the key.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.TearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Called during the chain of responsibility for a tear down operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="item">The item that is being torn down.</param>
      <returns>The torn down object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.TryGetTypeFromBuildKey(System.Object,System.Type@)">
      <summary>
            Trys to get the <see cref="T:System.Type" /> from <paramref name="buildKey" />.
            </summary>
      <param name="buildKey">The build key to get the <see cref="T:System.Type" />.</param>
      <param name="type">
      </param>
      <returns>true if the <see cref="T:System.Type" /> was found; otherwise, false.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2">
      <summary>
            Represents a generic strategy for all injection attribute processors.
            </summary>
      <typeparam name="TMemberInfo">The <see cref="T:System.Type" /> of member to reflect.</typeparam>
      <typeparam name="TDefaultInjectionAttribute">The <see cref="T:System.Type" /> of attribute for the member.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2.AddParametersToPolicy(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.IMemberInfo{`0},System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Adds <paramref name="parameters" /> to the appropriate policy.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="member">The member that's being reflected over.</param>
      <param name="parameters">The parameters used to satisfy the member call.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2.GetMembers(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Retrieves the list of members to iterate looking for 
            injection attributes, such as properties and constructor 
            parameters.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">Existing object being built, if available.</param>
      <returns>
            An enumerable wrapper around the <see cref="T:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1" /> interfaces that
            represent the members to be inspected for reflection.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2.MemberRequiresProcessing(Microsoft.Practices.ObjectBuilder2.IMemberInfo{`0})">
      <summary>
            Determine whether a member should be processed. 
            </summary>
      <param name="member">The member to determine processing.</param>
      <returns>true if the member needs processing; otherwise, false.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertyReflectionStrategy`1">
      <summary>
            Strategy that performs injection of method policies.
            </summary>
      <typeparam name="TDefaultParameterAttribute">The <see cref="T:System.Type" /> of attribute to look for in the property.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyReflectionStrategy`1.AddParametersToPolicy(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.PropertyInfo},System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Adds <paramref name="parameters" /> to the appropriate policy.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="member">The member that's being reflected over.</param>
      <param name="parameters">The parameters used to satisfy the method.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyReflectionStrategy`1.GetMembers(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Retrieves the list of properties to iterate looking for injection attributes.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">Existing object being built, if available.</param>
      <returns>
            An enumerable wrapper around the <see cref="T:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1" /> interfaces that
            represent the members to be inspected for reflection.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyReflectionStrategy`1.MemberRequiresProcessing(Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.PropertyInfo})">
      <summary>
            Determine whether a member should be processed. 
            </summary>
      <param name="member">The member to determine processing.</param>
      <returns>true if the member needs processing; otherwise, false.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodReflectionStrategy`2">
      <summary>
            Strategy that performs injection of method policies.
            </summary>
      <typeparam name="TInjectionMethodAttribute">The <see cref="T:System.Type" /> of attribute to look for in the method.</typeparam>
      <typeparam name="TDefaultParameterAttribute">The <see cref="T:System.Type" /> of the default parameter attribute.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodReflectionStrategy`2.AddParametersToPolicy(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.MethodInfo},System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Adds <paramref name="parameters" /> to the appropriate policy.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="member">The member that's being reflected over.</param>
      <param name="parameters">The parameters used to satisfy the method.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodReflectionStrategy`2.GetMembers(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Retrieves the list of methods to iterate looking for injection attributes.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">Existing object being built, if available.</param>
      <returns>
            An enumerable wrapper around the <see cref="T:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1" /> interfaces that
            represent the members to be inspected for reflection.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodReflectionStrategy`2.MemberRequiresProcessing(Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.MethodInfo})">
      <summary>
            Determine whether a member should be processed. 
            </summary>
      <param name="member">The member to determine processing.</param>
      <returns>true if the member needs processing; otherwise, false.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator">
      <summary>
            Represents a locator that can be read from.
            </summary>
      <remarks>
        <para>A locator is a dictionary of keys to values, but it keeps the values with
            weak references, so that locating an object does not keep it alive. If you
            want to keep the object alive too, you should consider using an
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />.</para>
        <para>Locators have a built-in concept of hierarchy, so you can ask questions
            of a locator and tell it whether to return results from the current locator
            only, or whether to ask the parent locator when local lookups fail.</para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.FindBy(System.Predicate{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
      <summary>
            Finds objects in the locator using the predicate, and returns a temporary locator
            filled with the found objects.
            </summary>
      <param name="predicate">The predicate to test whether to include an object.</param>
      <returns>The new locator</returns>
      <exception cref="T:System.ArgumentNullException">Predicate is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get``1">
      <summary>
            Gets an object from the locator, registered with the key of typeof(T).
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <returns>The object, if found; null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get``1(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator">
      <summary>
            Represents an abstract implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class with a parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
      <param name="parentLocator">A parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.FindBy(System.Predicate{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
      <summary>
            Finds objects in the locator using the predicate, and returns a temporary locator
            filled with the found objects.
            </summary>
      <param name="predicate">The predicate to test whether to include an object.</param>
      <returns>The new locator</returns>
      <exception cref="T:System.ArgumentNullException">Predicate is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get``1">
      <summary>
            Gets an object from the locator, registered with the key of typeof(T).
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <returns>The object, if found; null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get``1(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator">
      <summary>
            Represents a locator that can be read from and written to.
            </summary>
      <remarks>
        <para>
            A locator is dictionary of keys to values, but it keeps the values with
            weak references, so that locating an object does not keep it alive. If you
            want to keep the object alive too, you should consider using an
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />.
            </para>
        <para>
            Locators have a built-in concept of hierarchy, so you can ask questions
            of a locator and tell it whether to return results from the current locator
            only, or whether to ask the parent locator when local lookups fail.</para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator">
      <summary>
            Represents an abstract implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator" /> class with a parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
      <param name="parentLocator">A parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> that wraps an existing locator
            to ensure items are not written into the locator.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class with an <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> to wrap.
            </summary>
      <param name="innerLocator">The inner locator to be wrapped.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ValueResolutionAttribute">
      <summary>
            Base class for attributes used to mark members or
            parameters as dependencies to be injected.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ValueResolutionAttribute.EmitResolveDependency(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Type)">
      <summary>
            When implemented by deriving classes, this method emits
            the IL needed to resolve the dependency when the build
            plan is invoked.
            </summary>
      <param name="ilContext">Context emit the IL to.</param>
      <param name="compileTimeContext">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently
            being used (at "compile" time) to create the build plan.</param>
      <param name="typeToBuild">The type of the dependency to resolve.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy">
      <summary>
            Represents a builder policy interface. Since there are no fixed requirements
            for policies, it acts as a marker interface from which to derive all other
            policy interfaces.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IParameterResolverPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> used when a build plan creation
            strategy needs to emit code to resolve a method parameter.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IParameterResolverPolicy.EmitResolveParameter(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ParameterInfo,System.Object)">
      <summary>
            Emit the code to resolve the given parameter.
            </summary>
      <param name="ilContext">The context to use to emit the IL.</param>
      <param name="buildContext">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently being used to create the build plan.</param>
      <param name="parameter">The parameter to resolve.</param>
      <param name="buildKey">Build key being used while creating the build plan.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that will look for a build plan
            in the current context. If it exists, it invokes it, otherwise
            it creates one and stores it for later, and invokes it.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.AmbiguousInjectionConstructor">
      <summary>
              Looks up a localized string similar to The type {0} has multiple constructors of length {1}. Unable to disambiguate..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.CannotExtractTypeFromBuildKey">
      <summary>
              Looks up a localized string similar to Cannot extract type from build key {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MissingDependency">
      <summary>
              Looks up a localized string similar to Could not resolve dependency for build key {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.ProvidedStringArgMustNotBeEmpty">
      <summary>
              Looks up a localized string similar to The provided string argument must not be empty..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.UnknownNotPresentBehavior">
      <summary>
              Looks up a localized string similar to Unknown NotPresentBehavior {0}.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.InjectionConstructorAttribute">
      <summary>
            Indicates which constructor on an object will be used for dependency injection.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.CreationStrategy">
      <summary>
            Represents a strategy which creates objects.
            </summary>
      <remarks>
        <para>This strategy looks for policies in the context registered under the interface type
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ICreationPolicy" />. If it cannot find a policy on how to create the object,
            it will select the first constructor that returns from reflection, and re-runs the chain
            to create all the objects required to fulfill the constructor's parameters.</para>
        <para>If the Build method is passed an object via the existing parameter, then it
            will do nothing (since the object already exists). This allows this strategy to be
            in the chain when running dependency injection on existing objects, without fear that
            it will attempt to re-create the object.</para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.CreationStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that can create and return an <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy" />
            for the given build key.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy.CreatePlan(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create a build plan using the given context and build key.
            </summary>
      <param name="context">Current build context.</param>
      <param name="buildKey">Current build key.</param>
      <returns>The build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanMethod">
      <summary>
            A delegate type that defines the signature of the
            dynamic method created by the build plans.
            </summary>
      <param name="context">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> used to build up the object.</param>
      <param name="buildKey">Build key.</param>
      <param name="existing">Existing object being injected (null if new creation).</param>
      <returns>The built up object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy">
      <summary>
            A build plan is an object that, when invoked, will create a new object
            or fill in a given existing one. It encapsulates all the information
            gathered by the strategies to construct a particular object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Creates an instance of this build plan's type, or fills
            in the existing type if passed in.
            </summary>
      <param name="context">Context used to build up the object.</param>
      <param name="buildKey">Build key used to look up policies in the context.</param>
      <param name="existing">Existing object. If null, typically will create a new instance.</param>
      <returns>The built up object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy" /> that runs the
            given delegate to execute the plan.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertySetterStrategy">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> which sets property values.
            </summary>
      <remarks>
            This strategy looks for policies in the context registered under the interface type
            <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySetterPolicy" />, and sets the property values. If no policy is
            found, the no property values are set.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertySetterStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.  Looks for the <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySetterPolicy" /> and
            sets the value for the property if found.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ParameterAttribute">
      <summary>
            Indicates dependency injection members, whose value at 
            build time will be determined by the <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> returned 
            from the attribute <see cref="M:Microsoft.Practices.ObjectBuilder2.ParameterAttribute.CreateParameter(System.Type)" /> factory method.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ParameterAttribute.CreateParameter(System.Type)">
      <summary>
            Creates a parameter for use with various <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> implementations 
            that can process <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" />s.
            </summary>
      <param name="annotatedMemberType">The type of the annotated member, such as a property or a 
            constructor parameter.</param>
      <returns>The parameter instance that knows how to retrieve a value for the dependency.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyAttribute">
      <summary>
            Attribute applied to properties and constructor parameters, to describe when the dependency
            injection system should inject an object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyAttribute.#ctor">
      <summary>
            c
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyAttribute.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyAttribute" /> class with a build key.
            </summary>
      <param name="buildKey">The key of the object to build.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyAttribute.CreateParameter(System.Type)">
      <summary>
            Creates a parameter for use with various <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> implementations 
            that can process <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" />s.
            </summary>
      <param name="annotatedMemberType">The type of the annotated member, such as a property or a 
            constructor parameter.</param>
      <returns>The parameter instance that knows how to retrieve a value for the dependency.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DependencyAttribute.BuildKey">
      <summary>
            Gets the key of the object to be built.
            </summary>
      <value>
            The key of the object to be built.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DependencyAttribute.NotPresentBehavior">
      <summary>
            Gets or sets the behaviour when the dependecy can't be found.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ICreationPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.CreationStrategy" />.
            </summary>d
        </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ICreationPolicy.Create(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create the object for the given <paramref name="context" /> and <paramref name="buildKey" />.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ICreationPolicy.GetConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Gets the constructor to be used to create the object.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The constructor to use; returns null if no suitable constructor can be found.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ICreationPolicy.GetParameters(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ConstructorInfo)">
      <summary>
            Gets the parameter values to be passed to the constructor.
            </summary>
      <param name="context">The builder context.</param>
      <param name="constructor">The constructor that will be used.</param>
      <returns>An array of parameters to pass to the constructor.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ICreationPolicy.SupportsReflection">
      <summary>
            Determines if the policy supports reflection.
            </summary>
      <value>
            true if the policy supports reflection; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy">
      <summary>
            Default creation policy which selects the first public constructor
            of an object, using the builder to resolve/create any parameters the
            constructor requires.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.Create(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create the object for the given <paramref name="context" /> and <paramref name="buildKey" />.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.GetBuildKeyFromType(System.Type)">
      <summary>
            Gets the build key from the type.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> of object to be built.</param>
      <returns>The build key for the object being built.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.GetConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Gets the constructor to be used to create the object.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The constructor to use; returns null if no suitable constructor can be found.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.GetParameters(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ConstructorInfo)">
      <summary>
            Gets the parameter values to be passed to the constructor.
            </summary>
      <param name="context">The builder context.</param>
      <param name="constructor">The constructor that will be used.</param>
      <returns>An array of parameters to pass to the constructor.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.GetTypeFromBuildKey(System.Object)">
      <summary>
            Gets the <see cref="T:System.Type" /> of object to build from the <paramref name="buildKey" />.
            </summary>
      <param name="buildKey">The key of object to be built.</param>
      <returns>The <see cref="T:System.Type" /> of object to be built.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DefaultCreationPolicy.SupportsReflection">
      <summary>
            Determines if the policy supports reflection.
            </summary>
      <value>
            Returns true.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ConstructorReflectionStrategy`2">
      <summary>
            Strategy that performs injection of constructor policies.
            </summary>
      <typeparam name="TInjectionConstructorAttribute">The <see cref="T:System.Type" /> of attribute to look for in the constructor.</typeparam>
      <typeparam name="TDefaultInjectionAttribute">The <see cref="T:System.Type" /> of the default constructor attribute.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorReflectionStrategy`2.AddParametersToPolicy(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.ConstructorInfo},System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Adds <paramref name="parameters" /> to the appropriate policy.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="member">The member that's being reflected over.</param>
      <param name="parameters">The parameters used to satisfy the constructor.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorReflectionStrategy`2.GetMembers(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Retrieves the list of constructors to iterate looking for injection attributes.
            </summary>
      <param name="context">The build context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">Existing object being built, if available.</param>
      <returns>
            An enumerable wrapper around the <see cref="T:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1" /> interfaces that
            represent the members to be inspected for reflection.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorReflectionStrategy`2.MemberRequiresProcessing(Microsoft.Practices.ObjectBuilder2.IMemberInfo{System.Reflection.ConstructorInfo})">
      <summary>
            Determine whether a constructor should be processed. 
            </summary>
      <param name="member">The member to determine processing.</param>
      <returns>Always returns true.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingStrategy">
      <summary>
            Represents a strategy for mapping build keys in the build up operation.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.  Looks for the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy" />
            and if found maps the build key for the current operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> which will notify an object about
            the completion of a <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)" /> operation, or start of a
            <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)" /> operation.
            </summary>
      <remarks>
            This strategy checks the object that is passing through the builder chain to see if it
            implements IBuilderAware and if it does, it will call <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnBuiltUp(System.Object)" />
            and <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnTearingDown" />. This strategy is meant to be used from the
            <see cref="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PostInitialization" /> stage.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy.TearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Called during the chain of responsibility for a tear down operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="item">The item that is being torn down.</param>
      <returns>The torn down object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException">
      <summary>
            Represents an invalid combination of dependency injection attributes were used.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException.#ctor(System.Type,System.String)">
      <summary>
            Initialzie a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException" /> class with the <see cref="T:System.Type" /> and member name.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> of object with the invalid attribute.</param>
      <param name="memberName">The member name of <paramref name="type" /> with the invalid attribute.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException.#ctor">
      <summary>
            Constructor for compliance with .NET patterns. do not use.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException.#ctor(System.String)">
      <summary>
             Constructor for compliance with .NET patterns. do not use.
            </summary>
      <param name="message">Some random string.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor for compliance with .NET patterns. Do not use.
            </summary>
      <param name="message">Some random string.</param>
      <param name="innerException">Some other exception.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.InvalidAttributeException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain">
      <summary>
            This interface defines a standard method to convert any 
            <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> regardless
            of the stage enum into a regular, flat strategy chain.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain.MakeStrategyChain">
      <summary>
            Convert this <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> into
            a flat <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1">
      <summary>
            Represents a chain of responsibility for builder strategies partitioned by stages.
            </summary>
      <typeparam name="TStageEnum">The stage enumeration to partition the strategies.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.#ctor(Microsoft.Practices.ObjectBuilder2.StagedStrategyChain{`0})">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> class with an inner strategy chain to use when building.
            </summary>
      <param name="innerChain">The inner strategy chain to use first when finding strategies in the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.Add(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy,`0)">
      <summary>
            Adds a strategy to the chain at a particular stage.
            </summary>
      <param name="strategy">The strategy to add to the chain.</param>
      <param name="stage">The stage to add the strategy.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.AddNew``1(`0)">
      <summary>
            Add a new strategy for the <paramref name="stage" />.
            </summary>
      <typeparam name="TStrategy">The <see cref="T:System.Type" /> of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /></typeparam>
      <param name="stage">The stage to add the strategy.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.Clear">
      <summary>
            Clear the current strategy chain list.
            </summary>
      <remarks>
            This will not clear the inner strategy chain if this instane was created with one.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.GetStrategiesInStage(`0)">
      <summary>
            Gets the strategies in the <paramref name="stage" />.
            </summary>
      <param name="stage">The stage to get the strategies.</param>
      <returns>A collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> instances in the <paramref name="stage" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.MakeStrategyChain">
      <summary>
            Makes a strategy chain based on this instance.
            </summary>
      <returns>A new <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ResolveAttributeBase">
      <summary>
            This base class provides the logic to generate IL that
            calls into the <see cref="M:Microsoft.Practices.ObjectBuilder2.DependencyResolver.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.NotPresentBehavior)" /> method
            to resolve a dependency via recursive call into the build chain.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttributeBase.EmitResolveDependency(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Type)">
      <summary>
            Emit the code to call the <see cref="M:Microsoft.Practices.ObjectBuilder2.DependencyResolver.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.NotPresentBehavior)" />
            method on the requested type.
            </summary>
      <param name="ilContext">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" /> used
            to generate the IL.</param>
      <param name="compileTimeContext">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> being used
            to create the build plan.</param>
      <param name="typeToBuild">Type of object to resolve.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttributeBase.GetNotPresentBehavior">
      <summary>
            Return a value for the NotPresentBehavior parameter passed
            to the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyResolver" />.
            </summary>
      <returns>An integer value corresponding to one of the values 
            of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior" /> enum.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttributeBase.EmitBuildKey(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,System.Type)">
      <summary>
            Generate the IL to create the build key
            to use when resolving the dependency.
            </summary>
      <param name="ilContext">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" /> to
            emit IL to.</param>
      <param name="typeToBuild">The type of the dependency being resolved.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.AttributeParameterResolverPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameterResolverPolicy" /> that uses attributes
            on the parameters to drive the resolution.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.AttributeParameterResolverPolicy`1.EmitResolveParameter(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ParameterInfo,System.Object)">
      <summary>
            Emit the code to resolve the given parameter.
            </summary>
      <remarks>This policy does the resolution by looking for a <see cref="T:Microsoft.Practices.ObjectBuilder2.ValueResolutionAttribute" />
            on the parameter. If there isn't one, it falls back to using the default type provided
            via the <typeparamref name="TDefaultResolverAttribute" /> type parameter.</remarks>
      <param name="ilContext">The context to use to emit the IL.</param>
      <param name="buildContext">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently being used to create the build plan.</param>
      <param name="parameter">The parameter to resolve.</param>
      <param name="buildKey">Build key being used while creating the build plan.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer">
      <summary>
            Represents a lifetime container.
            </summary>
      <remarks>
            A lifetime container tracks the lifetime of an object, and implements
            IDisposable. When the container is disposed, any objects in the
            container which implement IDisposable are also disposed.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Add(System.Object)">
      <summary>
            Adds an object to the lifetime container.
            </summary>
      <param name="item">The item to be added to the lifetime container.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Contains(System.Object)">
      <summary>
            Determine if a given object is in the lifetime container.
            </summary>
      <param name="item">
            The item to locate in the lifetime container.
            </param>
      <returns>
            Returns true if the object is contained in the lifetime
            container; returns false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Remove(System.Object)">
      <summary>
            Removes an item from the lifetime container. The item is
            not disposed.
            </summary>
      <param name="item">The item to be removed.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Count">
      <summary>
            Gets the number of references in the lifetime container
            </summary>
      <value>
            The number of references in the lifetime container
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.LifetimeContainer">
      <summary>
            Represents a lifetime container.
            </summary>
      <remarks>
            A lifetime container tracks the lifetime of an object, and implements
            IDisposable. When the container is disposed, any objects in the
            container which implement IDisposable are also disposed.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Add(System.Object)">
      <summary>
            Adds an object to the lifetime container.
            </summary>
      <param name="item">The item to be added to the lifetime container.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Contains(System.Object)">
      <summary>
            Determine if a given object is in the lifetime container.
            </summary>
      <param name="item">
            The item to locate in the lifetime container.
            </param>
      <returns>
            Returns true if the object is contained in the lifetime
            container; returns false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Dispose">
      <summary>
            Releases the resources used by the <see cref="T:Microsoft.Practices.ObjectBuilder2.LifetimeContainer" />. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Dispose(System.Boolean)">
      <summary>
            Releases the managed resources used by the DbDataReader and optionally releases the unmanaged resources. 
            </summary>
      <param name="disposing">
            true to release managed and unmanaged resources; false to release only unmanaged resources.
            </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the lifetime container.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the life time container. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Remove(System.Object)">
      <summary>
            Removes an item from the lifetime container. The item is
            not disposed.
            </summary>
      <param name="item">The item to be removed.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Count">
      <summary>
            Gets the number of references in the lifetime container
            </summary>
      <value>
            The number of references in the lifetime container
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPropertyResolverPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> used when a build plan creation
            strategy needs to emit code to resolve a property.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPropertyResolverPolicy.EmitResolveProperty(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Emit the code to resolve the given property.
            </summary>
      <param name="ilContext">The context to use to emit the IL.</param>
      <param name="buildContext">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently being used to create the build plan.</param>
      <param name="prop">The property to resolve.</param>
      <param name="buildKey">Build key being used while creating the build plan.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy">
      <summary>
            Represents a builder policy for mapping build keys.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy.Map(System.Object)">
      <summary>
            Maps the build key.
            </summary>
      <param name="buildKey">The build key to map.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext">
      <summary>
            Represents the context in which a build-up or tear-down operation runs.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderContext.GetNextInChain(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Retrieves the next item in the strategy chain, relative to an existing item.
            </summary>
      <param name="currentStrategy">The strategy that is currently running</param>
      <returns>
            The next strategy in the chain; returns null if the given strategy
            was last in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.HeadOfChain">
      <summary>
            Gets the head of the strategy chain.
            </summary>
      <returns>
            The strategy that's first in the chain; returns null if there are no
            strategies in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Lifetime">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </summary>
      <value>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Locator">
      <summary>
            Gets the locator available to the strategies.
            </summary>
      <value>
            The locator available to the strategies.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.OriginalBuildKey">
      <summary>
            Gets the original build key for the build operation.
            </summary>
      <value>
            The original build key for the build operation.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Policies">
      <summary>
            Gets the policies for the current context. 
            </summary>
      <remarks>
            Any modifications will be transient (meaning, they will be forgotten when 
            the outer BuildUp for this context is finished executing).
            </remarks>
      <value>
            The policies for the current context.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Guard">
      <summary>
            Represents a simple class for validating parameters and throwing exceptions.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Guard.ArgumentNotNull(System.Object,System.String)">
      <summary>
            Validates <paramref name="argumentValue" /> is not null and throws <see cref="T:System.ArgumentNullException" /> if it is null.
            </summary>
      <param name="argumentValue">The value to validate.</param>
      <param name="argumentName">The name of <paramref name="argumentValue" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Guard.ArgumentNotNullOrEmpty(System.String,System.String)">
      <summary>
            Validates <paramref name="argumentValue" /> is not null or an empty string and throws <see cref="T:System.ArgumentNullException" /> if it is null or an empty string .
            </summary>
      <param name="argumentValue">The value to validate.</param>
      <param name="argumentName">The name of <paramref name="argumentValue" />.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SingletonStrategy">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> which allows objects to be
            singletons.
            </summary>
      <remarks>
            This strategy looks for policies in the context registered under the interface type
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ISingletonPolicy" />. It uses the locator in the build context to rememeber
            singleton objects, and the lifetime container contained in the locator to ensure they
            are not garbage collected. Upon the second request for an object, it will short-circuit
            the strategy chain and return the singleton instance (and will not re-inject the
            object).
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation and determines if the object should be a singlton.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPropertySetterPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.PropertySetterStrategy" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IPropertySetterPolicy.Properties">
      <summary>
            Gets a collection of properties to be called on the object instance.
            </summary>
      <value>
            A collection of properties to be called on the object instance.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertySetterPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.PropertySetterStrategy" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.PropertySetterPolicy.Properties">
      <summary>
            Gets a collection of properties to be called on the object instance.
            </summary>
      <value>
            A collection of properties to be called on the object instance.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1">
      <summary>
            Interface used by the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReflectionStrategy`2" /> to encapsulate 
            the information required from members that use the strategy. This interface is required because direct access to
            the <see cref="P:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.MemberInfo" /> object may not give the desired results.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>
            Gets the custom attributes of the member.
            </summary>
      <returns>An array of the custom attributes.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.GetParameters">
      <summary>
            Gets the parameters to be passed to the member.
            </summary>
      <returns>The parameters to be passed to the member.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.MemberInfo">
      <summary>
            Gets the original <see cref="P:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.MemberInfo" />.
            </summary>
      <value>
            The original <see cref="P:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.MemberInfo" />.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IMemberInfo`1.Name">
      <summary>
            Gets the name of the member.
            </summary>
      <value>
            The name of the member.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo">
      <summary>
            Represents the member inforamation for a <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo.#ctor(System.Reflection.PropertyInfo)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo" /> class with a <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
      <param name="prop">The <see cref="T:System.Reflection.PropertyInfo" /> to initialize the class.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>
            Gets the custom attributes for the property.
            </summary>
      <param name="attributeType">The <see cref="T:System.Type" /> of the attributes to get from the property.</param>
      <param name="inherit">true to get inherited attrubutes; otherwise, false.</param>
      <returns>An array of the custom attributes.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo.GetParameters">
      <summary>
            The parameters for the property.
            </summary>
      <returns>An array of <see cref="T:System.Reflection.ParameterInfo" /> objects.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo.MemberInfo">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
      <value>
            The <see cref="T:System.Reflection.PropertyInfo" />.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.PropertyMemberInfo.Name">
      <summary>
            Gets the name of the property.
            </summary>
      <value>
            The name of the poperty.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IParameter">
      <summary>
            Represents a single parameter used for constructor and method calls, and
            property setting.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IParameter.GetParameterType(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the type of the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's type.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IParameter.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter">
      <summary>
            An implementation helper class for <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> which can be used
            when you know the type of the parameter value ahead of time.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter.type">
      <summary>
            The parameter type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter" /> class
            using the given type.
            </summary>
      <param name="type">The parameter type.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter.GetParameterType(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the type of the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's type.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.KnownTypeParameter.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IMethodCallPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.MethodCallStrategy" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IMethodCallPolicy.Methods">
      <summary>
            Gets a collection of methods to be called on the object instance.
            </summary>
      <value>
            A collection of methods to be called on the object instance.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyParameter">
      <summary>
            Parameter that performs value retrieval depending on dependency injection attributes.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyParameter.#ctor(System.Object,Microsoft.Practices.ObjectBuilder2.NotPresentBehavior)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyParameter" /> class with a build key and behavior.
            </summary>
      <param name="buildKey">The key of the object begin built.</param>
      <param name="notPresentBehavior">One of the <see cref="P:Microsoft.Practices.ObjectBuilder2.DependencyParameter.NotPresentBehavior" /> values.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyParameter.GetParameterType(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the type of the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's type.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyParameter.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DependencyParameter.BuildKey">
      <summary>
            Gets the key for the object being built.
            </summary>
      <value>
            The key for the object being built.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DependencyParameter.NotPresentBehavior">
      <summary>
            Gets the behaviour for missing dependencies.
            </summary>
      <value>
            One of the <see cref="P:Microsoft.Practices.ObjectBuilder2.DependencyParameter.NotPresentBehavior" /> values.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy" /> implementation
            that constructs a build plan via dynamic IL emission.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy.#ctor(Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain)">
      <summary>
            Construct a <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy" /> that
            uses the given strategy chain to construct the build plan.
            </summary>
      <param name="strategies">
      </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy.CreatePlan(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Construct a build plan.
            </summary>
      <param name="context">The current build context.</param>
      <param name="buildKey">The current build key.</param>
      <returns>The created build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IMethodCallInfo">
      <summary>
            Encapsulates a method call.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IMethodCallInfo.Execute(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Execute the method to be called.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo">
      <summary>
            Encapsulates a call to a named method.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo.#ctor(System.String,Microsoft.Practices.ObjectBuilder2.IParameter[])">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo" /> class with an array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="methodName">The name of the method to execute.</param>
      <param name="parameters">An array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo" /> class with a collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="methodName">The name of the method to execute.</param>
      <param name="parameters">A collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo.Execute(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Execute the method to be called.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodCallStrategy">
      <summary>
            Represents a strategy to call method.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodCallStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation. Looks for a method call policy for the <paramref name="buildKey" /> and uses it to call a method if found.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.AttributePropertyResolverPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertyResolverPolicy" /> that chooses
            properties that are marked with the given <typeparamref name="TDefaultResolverAttribute" />
            attribute.
            </summary>
      <typeparam name="TDefaultResolverAttribute">
      </typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.AttributePropertyResolverPolicy`1.EmitResolveProperty(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Emit the code to resolve the given property.
            </summary>
      <param name="ilContext">The context to use to emit the IL.</param>
      <param name="buildContext">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently being used to create the build plan.</param>
      <param name="prop">The property to resolve.</param>
      <param name="buildKey">Build key being used while creating the build plan.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException">
      <summary>
            Represents that a dependency could not be resolved.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with no extra information.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the given message.
            </summary>
      <param name="message">Some random message.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.String,System.Exception)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the given
            message and inner exception.
            </summary>
      <param name="message">Some random message</param>
      <param name="innerException">Inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the build key of the object begin built.
            </summary>
      <param name="buildKey">The build key of the object begin built.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior">
      <summary>
            Enumeration describing how to handle when a dependency is not present.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior.Build">
      <summary>
            Create the object.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior.Null">
      <summary>
            Return null. Do not build the object.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior.Throw">
      <summary>
            Throw a dependency missing exception.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.LookupParameter">
      <summary>
            Looks up the parameter value in the build context locator.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LookupParameter.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.LookupParameter" /> class.
            </summary>
      <param name="key">The key to look the object up with.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LookupParameter.GetParameterType(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the type of the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's type.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LookupParameter.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Locator">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> and <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.Locator" /> class. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.Locator" /> class as a child of the <paramref name="parentLocator" />. 
            </summary>
      <param name="parentLocator">The parent locator.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">Key or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Locator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ValueParameter`1">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> which directly holds a value to
            be used for the parameter.
            </summary>
      <typeparam name="TValue">The type of the parameter value.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ValueParameter`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ValueParameter`1" /> class.
            </summary>
      <param name="value">The value for the parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ValueParameter`1.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ValueParameter">
      <summary>
            Represents a parameter which directly holds a value to
            be used for the parameter.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ValueParameter.#ctor(System.Type,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ValueParameter" /> class.
            </summary>
      <param name="valueType">The type of the parameter value.</param>
      <param name="value">The value for the parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ValueParameter.GetValue(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Gets the parameter value.
            </summary>
      <param name="context">The build context.</param>
      <returns>The parameter's value.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ITypeBasedBuildKey">
      <summary>
            Represents a build key based on type.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ITypeBasedBuildKey.Type">
      <summary>
            Gets the <see cref="P:Microsoft.Practices.ObjectBuilder2.ITypeBasedBuildKey.Type" /> that represents the key.
            </summary>
      <value>
            The <see cref="P:Microsoft.Practices.ObjectBuilder2.ITypeBasedBuildKey.Type" /> that represents the key.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IConstructorChooserPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that, when implemented,
            will determine which constructor to call from the build plan.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IConstructorChooserPolicy.ChooseConstructor(System.Type)">
      <summary>
            Choose the constructor to call for the given type.
            </summary>
      <param name="typeToConstruct">The type to construct.</param>
      <returns>The chosen constructor.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilder">
      <summary>
            Represents the main interface for an object builder.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <typeparam name="TTypeToBuild">The type to build.</typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)">
      <summary>
            Performs an unbuild operation.
            </summary>
      <typeparam name="TItem">The type to unbuild. If not provided, it will be inferred from the
            type of item.
            </typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="item">The item to tear down.</param>
      <returns>The torn down item.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Builder">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />. It contains all the default strategies shipped
            with ObjectBuilder.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.BuildUp``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <typeparam name="TTypeToBuild">The type to build.</typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)">
      <summary>
            Performs an unbuild operation.
            </summary>
      <typeparam name="TItem">The type to unbuild. If not provided, it will be inferred from the
            type of item.
            </typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="item">The item to tear down.</param>
      <returns>The torn down item.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPropertySetterInfo">
      <summary>
            Encapsulates a property setter.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPropertySetterInfo.Set(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Sets the value on the property.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1">
      <summary>
            Represents the member inforamation for a <see cref="T:System.Reflection.MethodBase" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1.#ctor(`0)">
      <summary>
            Initialize a new instace of the <see cref="T:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1" /> class with the method to wrap.
            </summary>
      <param name="memberInfo">
            The method to wrap.
            </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>
            Gets the custom attributes for the method.
            </summary>
      <param name="attributeType">The <see cref="T:System.Type" /> of the attributes to get from the method.</param>
      <param name="inherit">true to get inherited attrubutes; otherwise, false.</param>
      <returns>An array of the custom attributes.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1.GetParameters">
      <summary>
            The parameters for the method.
            </summary>
      <returns>An array of <see cref="T:System.Reflection.ParameterInfo" /> objects.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1.MemberInfo">
      <summary>
            Gets the wrapped method.
            </summary>
      <value>
            The wrapped method.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.MethodMemberInfo`1.Name">
      <summary>
            Gets the name of the method.
            </summary>
      <value>
            The name of the method.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPropertyChooserPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that returns a sequence
            of properties that should be injected for the given type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPropertyChooserPolicy.ChooseProperties(System.Type)">
      <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
      <param name="t">Type of object to examine.</param>
      <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo" /> objects
            that contain the properties to set.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertyChooserPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertyChooserPolicy" /> that looks
            for properties marked with the <typeparamref name="TResolutionAttribute" />
            attribute that are also settable and not indexers.
            </summary>
      <typeparam name="TResolutionAttribute">
      </typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertyChooserPolicy`1.ChooseProperties(System.Type)">
      <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
      <param name="t">Type of object to examine.</param>
      <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo" /> objects
            that contain the properties to set.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IMethodChooserPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that will examine the given
            types and return a sequence of <see cref="T:System.Reflection.MethodInfo" /> objects
            that should be called as part of building the object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IMethodChooserPolicy.GetMethods(System.Type)">
      <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
      <param name="t">Type of the target object.</param>
      <returns>Sequence of methods to call.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext">
      <summary>
            This object tracks the current state of the build plan generation,
            accumulates the IL, provides the preamble &amp; postamble for the dynamic
            method, and tracks things like local variables in the generated IL
            so that they can be reused across IL generation strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.#ctor(System.Type)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" /> that is initialized
            to handle creation of a dynamic method to build the given type.
            </summary>
      <param name="typeToBuild">Type that we're trying to create a build plan for.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetBuildMethod">
      <summary>
            Completes generation of the dynamic method and returns the
            generated dynamic method delegate.
            </summary>
      <returns>The created <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanMethod" /></returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadContext">
      <summary>
            Emit the IL to put the build context on top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadBuildKey">
      <summary>
            Emit the IL to put the current build key on top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadExisting">
      <summary>
            Emit the IL to put the current "existing" object on the top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitStoreExisting">
      <summary>
            Emit the IL to make the top of the IL stack our current "existing" object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadTypeOnStack(System.Type)">
      <summary>
            Emit the IL to load the given <see cref="T:System.Type" /> object onto the top of the IL stack.
            </summary>
      <param name="t">Type to load on the stack.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitResolveParameter(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ParameterInfo,System.Object)">
      <summary>
            Emit the IL needed to resolve the given method parameter.
            </summary>
      <remarks>This method looks in the context for a
            <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameterResolverPolicy" /> to generate the actual resolution code.</remarks>
      <param name="context">The current build context.</param>
      <param name="param">Parameter to resolve.</param>
      <param name="buildKey">The current build key.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitResolveProperty(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Emit the IL needed to resolve the given method parameter.
            </summary>
      <remarks>This method looks in the context for a
            <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertyResolverPolicy" /> to generate the actual resolution code.</remarks>
      <param name="context">The current build context.</param>
      <param name="prop">Property to resolve.</param>
      <param name="buildKey">The current build key.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetPropertyGetter``2(System.String)">
      <summary>
            A reflection helper method to make it easier to grab a property getter
            <see cref="T:System.Reflection.MethodInfo" /> for the given property.
            </summary>
      <typeparam name="TImplementor">Type that implements the property we want.</typeparam>
      <typeparam name="TProperty">Type of the property.</typeparam>
      <param name="name">Name of the property.</param>
      <returns>The property getter's <see cref="T:System.Reflection.MethodInfo" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetMethodInfo``1(System.String,System.Type[])">
      <summary>
            A reflection helper method that makes it easier to grab a <see cref="T:System.Reflection.MethodInfo" />
            for a method.
            </summary>
      <typeparam name="TImplementor">Type that implements the method we want.</typeparam>
      <param name="name">Name of the method.</param>
      <param name="argumentTypes">Types of arguments to the method.</param>
      <returns>The method's <see cref="T:System.Reflection.MethodInfo" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.IL">
      <summary>
            The underlying <see cref="T:System.Reflection.Emit.ILGenerator" /> that can be used to
            emit IL into the generated dynamic method.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.TypeToBuild">
      <summary>
            The type we're currently creating the method to build.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderStage">
      <summary>
            Enumeration to represent the object builder stages.
            </summary>
      <remarks>
            The order of the values in the enumeration is the order in which the stages are run.
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PreCreation">
      <summary>
            Strategies in this stage run before creation. Typical work done in this stage might
            include strategies that use reflection to set policies into the context that other
            strategies would later use.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.Creation">
      <summary>
            Strategies in this stage create objects. Typically you will only have a single policy-driven
            creation strategy in this stage.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.Initialization">
      <summary>
            Strategies in this stage work on created objects. Typical work done in this stage might
            include setter injection and method calls.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PostInitialization">
      <summary>
            Strategies in this stage work on objects that are already initialized. Typical work done in
            this stage might include looking to see if the object implements some notification interface
            to discover when its initialization stage has been completed.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ISingletonPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.SingletonStrategy" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ISingletonPolicy.IsSingleton">
      <summary>
            Determines if the object should be a singleton.
            </summary>
      <value>
            true if the object should be a singleton; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SingletonPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.SingletonStrategy" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonPolicy.#ctor(System.Boolean)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.SingletonPolicy" /> class with a 
            value determiniting if the the object should be singleton or not.
            </summary>
      <param name="isSingleton">true if the object should be a singleton; otherwise, false.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SingletonPolicy.IsSingleton">
      <summary>
            Determines if the object should be a singleton.
            </summary>
      <value>
            true if the object should be a singleton; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain">
      <summary>
            Represents a chain of responsibility for builder strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStrategyChain.GetNext(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Gets the next strategy in the chain, relative to the given strategy.
            </summary>
      <param name="currentStrategy">The current strategy.</param>
      <returns>The next strategy in the chain; returns null if the current
            strategy is the last in the chain.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStrategyChain.Reverse">
      <summary>
            Reverse the order of the strategy chain.
            </summary>
      <returns>The reversed strategy chain.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IStrategyChain.Head">
      <summary>
            Gets the head of the chain.
            </summary>
      <value>
            The head of the chain.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodCallStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that generates IL to call
            chosen methods (as specified by the current <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodChooserPolicy" />)
            as part of object build up.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodCallStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ConstructorChooserPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorChooserPolicy" /> that chooses
            constructors based on these criteria: first, pick a constructor marked with the
            <typeparamref name="TInjectionConstructorMarkerAttribute" /> attribute. If there
            isn't one, then choose the constructor with the longest parameter list. If that is ambiguous,
            then throw.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when the constructor to choose is ambiguous.</exception>
      <typeparam name="TInjectionConstructorMarkerAttribute">Attribute used to mark the constructor to call.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorChooserPolicy`1.ChooseConstructor(System.Type)">
      <summary>
             Choose the constructor to call for the given type.
             </summary>
      <param name="typeToConstruct">The type to construct.</param>
      <returns>The chosen constructor.</returns>
      <exception cref="T:System.InvalidOperationException">Thrown when the constructor to choose is ambiguous.</exception>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2">
      <summary>
            Represents a dictionary which stores the values as weak references instead of strong
            references. Null values are supported.
            </summary>
      <typeparam name="TKey">The key type</typeparam>
      <typeparam name="TValue">The value type</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Add(`0,`1)">
      <summary>
            Gets the count of the number of items in the dictionary.
            </summary>
      <value>
            The count of the number of items in the dictionary.
            </value>
      <remarks>
            Since the items in the dictionary are held by weak reference, the count value
            cannot be relied upon to guarantee the number of objects that would be discovered via
            enumeration. Treat the Count as an estimate only.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if the dictionary contains a value for the key.
            </summary>
      <param name="key">The key to look for.</param>
      <returns>true if the key is contained in the dictionary; otherwise, false.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the dictionary.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the dictionary. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Remove(`0)">
      <summary>
            Removes an item from the dictionary.
            </summary>
      <param name="key">The key of the item to be removed.</param>
      <returns>Returns true if the key was in the dictionary; return false otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.TryGet(`0,`1@)">
      <summary>
            Attempts to get a value from the dictionary.
            </summary>
      <param name="key">The key</param>
      <param name="value">The value</param>
      <returns>Returns true if the value was present; false otherwise.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Count">
      <summary>
            Returns a count of the number of items in the dictionary.
            </summary>
      <remarks>
            Since the items in the dictionary are held by weak reference, the count value
            cannot be relied upon to guarantee the number of objects that would be discovered via
            enumeration. Treat the Count as an estimate only.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Item(`0)">
      <summary>
            Retrieves a value from the dictionary.
            </summary>
      <param name="key">The key to look for.</param>
      <returns>The value in the dictionary.</returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key does exist in the dictionary.
            Since the dictionary contains weak references, the key may have been removed by the
            garbage collection of the object.</exception>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodCallPolicy">
      <summary>
            Represents a policy for <see cref="T:Microsoft.Practices.ObjectBuilder2.MethodCallStrategy" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.MethodCallPolicy.Methods">
      <summary>
            Gets a collection of methods to be called on the object instance.
            </summary>
      <value>
            A collection of methods to be called on the object instance.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderAware">
      <summary>
            Implemented on a class when it wants to receive notifications
            about the build process.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnBuiltUp(System.Object)">
      <summary>
            Called by the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy" /> when the object is being built up.
            </summary>
      <param name="buildKey">The key of the object that was just built up.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnTearingDown">
      <summary>
            Called by the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy" /> when the object is being torn down.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyResolver">
      <summary>
            Dependency resolver for resolving dependencies of objects being built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolver.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,Microsoft.Practices.ObjectBuilder2.NotPresentBehavior)">
      <summary>
            Resolves a dependency.
            </summary>
      <param name="context">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> of the build operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="behavior">Describes how to behave if the dependency is not found.</param>
      <returns>The dependent object. If the object is not found, and notPresent
            is set to <see cref="F:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior.Null" />, will return null.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo">
      <summary>
            Encapsulates a reflection method call.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo.#ctor(System.Reflection.MethodInfo,Microsoft.Practices.ObjectBuilder2.IParameter[])">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo" /> class with an array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="method">The method to execute.</param>
      <param name="parameters">An array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo.#ctor(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedMethodCallInfo" /> class with a collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="method">The method to execute.</param>
      <param name="parameters">A collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo.Execute(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Execute the method to be called.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo.Method">
      <summary>
            Gets the method to execute.
            </summary>
      <value>
            The method to execute.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReflectionMethodCallInfo.Parameters">
      <summary>
            Gets the parameters used in the method call.
            </summary>
      <value>
            The parameters used in the method call.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy">
      <summary>
            Represents a creation policy based on <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])" /></summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.#ctor(Microsoft.Practices.ObjectBuilder2.IParameter[])">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy" /> class with an array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="parameters">An array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy" /> class with a collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="parameters">A collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.Create(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create the object for the given <paramref name="context" /> and <paramref name="buildKey" />.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.GetConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Gets the constructor to be used to create the object.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The constructor to use; returns null if no suitable constructor can be found.</returns>
      <exception cref="T:System.NotImplementedException">
            Does not support getting a constructor.
            </exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.GetParameters(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ConstructorInfo)">
      <summary>
            Gets the parameter values to be passed to the constructor.
            </summary>
      <param name="context">The builder context.</param>
      <param name="constructor">The constructor that will be used.</param>
      <returns>An array of parameters to pass to the constructor.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy.SupportsReflection">
      <summary>
            Determines if the policy supports reflection.
            </summary>
      <value>
            Returns false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ResolveAttribute">
      <summary>
            This attribute is used to mark parameters and properties that
            should be injected.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttribute.#ctor">
      <summary>
            Create a new default <see cref="T:Microsoft.Practices.ObjectBuilder2.ResolveAttribute" /> that will
            cause the dependency to be built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttribute.#ctor(Microsoft.Practices.ObjectBuilder2.NotPresentBehavior)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.ResolveAttribute" /> with the given
            <see cref="T:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior" />.
            </summary>
      <param name="notPresentBehavior">NotPresentBehavior to use.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttribute.GetNotPresentBehavior">
      <summary>
            Used by the base class to translate the NotPresentBehavior into
            and integer for IL generation.
            </summary>
      <returns>An integer value corresponding to one of the values 
            of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NotPresentBehavior" /> enum.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ResolveAttribute.EmitBuildKey(Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext,System.Type)">
      <summary>
            Used by the base class to generate the IL to create the build key
            to use when resolving the dependency.
            </summary>
      <param name="ilContext">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" /> to
            emit IL to.</param>
      <param name="typeToBuild">The type of the dependency being resolved.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.NamedPropertySetterInfo">
      <summary>
            Encapsulates a call to a named property.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedPropertySetterInfo.#ctor(System.String,Microsoft.Practices.ObjectBuilder2.IParameter)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedPropertySetterInfo" /> class with the property name and the parameter value.
            </summary>
      <param name="propertyName">The property name.</param>
      <param name="value">The paramer value.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedPropertySetterInfo.Set(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Sets the value on the property.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPolicyList">
      <summary>
            A custom collection over <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Clear``1(System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Clear(System.Type,System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <param name="policyInterface">The type of policy to remove.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearAll">
      <summary>
            Removes all policies from the list.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearDefault``1">
      <summary>
            Removes a default policy.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearDefault(System.Type)">
      <summary>
            Removes a default policy.
            </summary>
      <param name="policyInterface">The type the policy was registered as.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get``1(System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get(System.Type,System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get``1(System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get(System.Type,System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.GetNoDefault``1(System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.GetNoDefault(System.Type,System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Set``1(``0,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Set(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <param name="policyInterface">The <see cref="T:System.Type" /> of the policy.</param>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.SetDefault``1(``0)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <typeparam name="TPolicyInterface">The interface to register the policy under.</typeparam>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.SetDefault(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <param name="policyInterface">The interface to register the policy under.</param>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PolicyList">
      <summary>
            A custom collection wrapper over <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.#ctor">
      <summary>
            Initialize a new instance of a <see cref="T:Microsoft.Practices.ObjectBuilder2.PolicyList" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.#ctor(Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Initialize a new instance of a <see cref="T:Microsoft.Practices.ObjectBuilder2.PolicyList" /> class with another policy list.
            </summary>
      <param name="innerPolicyList">An inner policy list to search.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Clear``1(System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Clear(System.Type,System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <param name="policyInterface">The type of policy to remove.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearAll">
      <summary>
            Removes all policies from the list.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearDefault``1">
      <summary>
            Removes a default policy.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearDefault(System.Type)">
      <summary>
            Removes a default policy.
            </summary>
      <param name="policyInterface">The type the policy was registered as.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get``1(System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get(System.Type,System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get``1(System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get(System.Type,System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.GetNoDefault``1(System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.GetNoDefault(System.Type,System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Set``1(``0,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Set(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <param name="policyInterface">The <see cref="T:System.Type" /> of the policy.</param>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.SetDefault``1(``0)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <typeparam name="TPolicyInterface">The interface to register the policy under.</typeparam>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.SetDefault(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <param name="policyInterface">The interface to register the policy under.</param>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.PolicyList.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodPropertySetterStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that generates IL to resolve properties
            on an object being built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodPropertySetterStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy">
      <summary>
            Represents a builder policy for mapping build keys.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy.#ctor(System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy" /> with the new build key.
            </summary>
      <param name="newBuildKey">
      </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy.Map(System.Object)">
      <summary>
            Map the <paramref name="buildKey" /> to a new build key.
            </summary>
      <param name="buildKey">The build key to mapl</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.StrategyChain">
      <summary>
            Represents a chain of responsibility for builder strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.#ctor">
      <summary>
            Initialzie a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.#ctor(System.Collections.IEnumerable)">
      <summary>
            Initialzie a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" /> class with a colleciton of strategies.
            </summary>
      <param name="strategies">A collection of strategies to initialize the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.Add(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Adds a strategy to the chain.
            </summary>
      <param name="strategy">The strategy to add to the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.AddRange(System.Collections.IEnumerable)">
      <summary>
            Adds strategies to the chain.
            </summary>
      <param name="strategyEnumerable">The strategies to add to the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.GetNext(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Gets the next strategy in the chain, relative to the given strategy.
            </summary>
      <param name="currentStrategy">The current strategy.</param>
      <returns>The next strategy in the chain; returns null if the current
            strategy is the last in the chain.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.Reverse">
      <summary>
            Reverse the order of the strategy chain.
            </summary>
      <returns>The reversed strategy chain.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.StrategyChain.Head">
      <summary>
            Gets the head of the chain.
            </summary>
      <value>
            The head of the chain.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.InjectionMethodAttribute">
      <summary>
            Indicateds the dependency injection should call a method during the build-up of an object.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy">
      <summary>
            A creation policy where the constructor to choose is derived from the parameters
            provided by the user.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.#ctor(System.Reflection.ConstructorInfo,Microsoft.Practices.ObjectBuilder2.IParameter[])">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy" /> class with a <see cref="T:System.Reflection.ConstructorInfo" /> and an array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to use to create the object.</param>
      <param name="parameters">An array of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.#ctor(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{Microsoft.Practices.ObjectBuilder2.IParameter})">
      <summary>
            Initalize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ActivatorCreationPolicy" /> class with a <see cref="T:System.Reflection.ConstructorInfo" /> and a collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.
            </summary>
      <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to use to create the object.</param>
      <param name="parameters">A collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IParameter" /> instances.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.Create(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create the object for the given <paramref name="context" /> and <paramref name="buildKey" />.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.GetConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Gets the constructor to be used to create the object.
            </summary>
      <param name="context">The builder context.</param>
      <param name="buildKey">The key for the object being built.</param>
      <returns>The constructor to use; returns null if no suitable constructor can be found.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.GetParameters(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Reflection.ConstructorInfo)">
      <summary>
            Gets the parameter values to be passed to the constructor.
            </summary>
      <param name="context">The builder context.</param>
      <param name="constructor">The constructor that will be used.</param>
      <returns>An array of parameters to pass to the constructor.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ConstructorCreationPolicy.SupportsReflection">
      <summary>
            Determines if the policy supports reflection.
            </summary>
      <value>
            Returns true.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodChooserPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodChooserPolicy" /> that selects
            methods by looking for the given <typeparamref name="TMarkerAttribute" />
            attribute on those methods.
            </summary>
      <typeparam name="TMarkerAttribute">Type of attribute used to mark methods
            to inject.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodChooserPolicy`1.GetMethods(System.Type)">
      <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
      <param name="t">Type of the target object.</param>
      <returns>Sequence of methods to call.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderContext">
      <summary>
            Represents the context in which a build-up or tear-down operation runs.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderContext" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.#ctor(Microsoft.Practices.ObjectBuilder2.IStrategyChain,Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderContext" /> class with a <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" />, 
            <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />, <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />, <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> and the 
            build key used to start this build operation. 
            </summary>
      <param name="chain">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this context.</param>
      <param name="locator">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" /> to use for this context.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this context.</param>
      <param name="policies">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> to use for this context.</param>
      <param name="originalBuildKey">
      </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.GetNextInChain(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Retrieves the next item in the strategy chain, relative to an existing item.
            </summary>
      <param name="currentStrategy">The strategy that is currently running</param>
      <returns>
            The next strategy in the chain; returns null if the given strategy
            was last in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.HeadOfChain">
      <summary>
            Gets the head of the strategy chain.
            </summary>
      <returns>
            The strategy that's first in the chain; returns null if there are no
            strategies in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Lifetime">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </summary>
      <value>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Locator">
      <summary>
            Gets the locator available to the strategies.
            </summary>
      <value>
            The locator available to the strategies.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.OriginalBuildKey">
      <summary>
            Gets the original build key for the build operation.
            </summary>
      <value>
            The original build key for the build operation.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Policies">
      <summary>
            Gets the policies for the current context. 
            </summary>
      <remarks>
            Any modifications will be transient (meaning, they will be forgotten when 
            the outer BuildUp for this context is finished executing).
            </remarks>
      <value>
            The policies for the current context.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo">
      <summary>
            Encapsulates a reflection property setting.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo.#ctor(System.Reflection.PropertyInfo,Microsoft.Practices.ObjectBuilder2.IParameter)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo" /> class with a property and paramter value.
            </summary>
      <param name="property">The property to use to set the value.</param>
      <param name="value">The value for the property.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo.Set(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Sets the value on the property.
            </summary>
      <param name="context">The current <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" />.</param>
      <param name="instance">The instance to use to execute the method.</param>
      <param name="buildKey">The key for the object being built.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo.Property">
      <summary>
            Gets the property for the setter call.
            </summary>
      <value>
            The property for the setter call.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReflectionPropertySetterInfo.Value">
      <summary>
            Gets the value for the property.
            </summary>
      <value>
            The value for the property.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that emits IL to call constructors
            as part of creating a build plan.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object,System.Object)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <remarks>Existing object is an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" />.</remarks>
      <param name="context">The context for the operation.</param>
      <param name="buildKey">The key for the object being built.</param>
      <param name="existing">The existing instance, if one was passed in, or
            if a previous strategy has already created the object.</param>
      <returns>The built object.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityInstanceElementCollection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElementCollection" /> that stores the
            collection of <see cref="T:Microsoft.Practices.Unity.Configuration.UnityInstanceElement" /> objects specified
            in the current configuration file.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityInstanceElementCollection.CreateNewElement">
      <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
      <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityInstanceElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElementCollection" /> that holds the collection of
            container elements specified in the config file.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection.CreateNewElement">
      <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
      <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection.Item(System.String)">
      <summary>
            Get a <see cref="T:Microsoft.Practices.Unity.Configuration.UnityContainerElement" /> by name.
            </summary>
      <param name="name">name to look up.</param>
      <returns>The element.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection.Item(System.Int32)">
      <summary>
            Get or set a <see cref="T:Microsoft.Practices.Unity.Configuration.UnityContainerElement" /> by index.
            </summary>
      <param name="index">Index to get or set at.</param>
      <returns>The element.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElementCollection.Default">
      <summary>
            Get the default (unnamed) container element.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityConfigurationSection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationSection" /> that contains the configuration
            for one or more <see cref="T:Microsoft.Practices.Unity.UnityContainer" />s.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityConfigurationSection.Containers">
      <summary>
            Provides access to the container information in the section.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElementCollection">
      <summary>
            Collection of <see cref="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement" /> elements
            from the configuration file. This collection can contain derived classes of
            <see cref="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElementCollection.OnDeserializeUnrecognizedElement(System.String,System.Xml.XmlReader)">
      <summary>
             Figure out the concrete type to create given the type attribute on the given
             xml reader. If not present, throws an exception.
            </summary>
      <returns>
            true if the unrecognized element was deserialized successfully; otherwise, false. The default is false.
            </returns>
      <param name="reader">An input stream that reads XML from the configuration file. </param>
      <param name="elementName">The name of the unrecognized element. </param>
      <exception cref="T:System.ArgumentException">elementName starts with the reserved prefix "config" or "lock".</exception>
      <exception cref="T:System.Configuration.ConfigurationErrorsException">The element specified in elementName is the &lt;clear&gt; element.</exception>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElementCollection.CreateNewElement">
      <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
      <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElementCollection.Item(System.String)">
      <summary>
            Get the given element by key.
            </summary>
      <param name="key">Name of element to find.</param>
      <returns>Element at the given key.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand">
      <summary>
            Interface for objects that will execute methods
            on the given container. Typically used for configuration
            of the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection">
      <summary>
            An <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> that composites other 
            <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> and runs them in order
            when executed.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection" /> with no contained
            command objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand})">
      <summary>
            Creates a new <see cref="T:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection" /> that contains
            the given sequence of commands.
            </summary>
      <param name="commands">
        <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> objects to add
            to this collection.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection.#ctor(Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand[])">
      <summary>
            Creates a new <see cref="T:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection" /> that contains
            the given set of commands.
            </summary>
      <param name="commands">The <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> to add to the collection.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.ContainerConfigurationCommandCollection.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Apply each of the <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> objects stored
            in this collection to the given <paramref name="container" />.
            </summary>
      <param name="container">The container to configure.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityTypeElementCollection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElementCollection" /> that stores the set of
            type elements in the config file.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityTypeElementCollection.CreateNewElement">
      <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
      <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityTypeElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElementCollection.Item(System.String)">
      <summary>
            Get access to a type element by name
            </summary>
      <param name="name">Name to look up by. This is not just the name element, it's of the form
            &lt;name&gt;:&lt;fully qualified type name&gt;.</param>
      <returns>The given element, or null if not in the collection.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElementCollection.Item(System.Int32)">
      <summary>
            Gets access to a type element to look up.
            </summary>
      <param name="index">The index to retrieve the element from.</param>
      <returns>The element.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityInstanceElement">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElement" /> that holds the information
            about instances to be placed in the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.GetConfigCommand">
      <summary>
            Get an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that will
            apply the configuration specified by this config element to the given
            container.
            </summary>
      <returns>The <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.Name">
      <summary>
            Name to use when registering this instance. Optional.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.Type">
      <summary>
            Type of this instance. Defaults to "string"
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.Value">
      <summary>
            Value to use to initialize the instance.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityInstanceElement.TypeConverter">
      <summary>
            The type converter to use to convert the Value into the instance.
            If not specified, we use the default converter for the type.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElement">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElement" /> that holds the information from
            the configuration file about which extensions to add to the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElement.GetConfigCommand">
      <summary>
            Get an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that will
            apply the configuration specified by this config element to the given
            container.
            </summary>
      <returns>The <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElement.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElement.Type">
      <summary>
            The type of extension to add to the container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerElement">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElement" /> that stores the configuration information
            for a single <see cref="T:Microsoft.Practices.Unity.IUnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerElement.GetConfigCommand">
      <summary>
            Retrieve an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that, when
            executed, will apply this object's configuration settings to the give container.
            </summary>
      <returns>The command object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerElement.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElement.Name">
      <summary>
            Name of this container configuration. The config may be retrieved by name.
            </summary>
      <remarks>This name is only used for lookup from the config file. If not 
            specified, this is the default container configuration.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElement.Types">
      <summary>
            The collection of &lt;type&gt; elements that contain the actual configuration entries.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElement.Extensions">
      <summary>
            The collection of &lt;extension&gt; elements that specify which extensions to add to the container.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElement.Instances">
      <summary>
            The collection of &lt;instance&gt; element that specify which instances to add to the container.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerElement.ExtensionConfig">
      <summary>
            The collection of extension configuration elements that are used to add
            arbitrary new extensions to the configuration file.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand">
      <summary>
            An <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that calls the
            <see cref="M:Microsoft.Practices.Unity.UnityContainer.Register(System.Type,System.Type,System.String)" /> method.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand.#ctor(System.Type,System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand" /> that registers
            the given type mapping as a default mapping.
            </summary>
      <param name="from">The type to map from.</param>
      <param name="to">The type to map to.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand.#ctor(System.Type,System.Type,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand" /> that registers
            the given type mapping with the given name.
            </summary>
      <param name="from">The type to map from.</param>
      <param name="to">The type to map to.</param>
      <param name="name">Name to use when registering.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterConfigurationCommand.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Apply this registration to the given container.
            </summary>
      <param name="container">
        <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.AssemblyQualifiedTypeNameConverter">
      <summary>
            A <see cref="T:System.ComponentModel.TypeConverter" /> that converts types
            to and from fully qualified type names.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AssemblyQualifiedTypeNameConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <summary>
            Determines whether the conversion is allowed.
            </summary>
      <returns>
            true if the conversion is allowed; otherwise, false. 
            </returns>
      <param name="type">The type to convert to.</param>
      <param name="ctx">The <see cref="T:System.ComponentModel.ITypeDescriptorContext"></see> object used for type conversion.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AssemblyQualifiedTypeNameConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <summary>
            Determines whether the conversion is allowed.
            </summary>
      <returns>
            true if the conversion is allowed; otherwise, false.
            </returns>
      <param name="type">The <see cref="T:System.Type"></see> to convert from.</param>
      <param name="ctx">The <see cref="T:System.ComponentModel.ITypeDescriptorContext"></see> object used for type conversions.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AssemblyQualifiedTypeNameConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
      <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that represents the converted value.
            </returns>
      <param name="culture">The <see cref="T:System.Globalization.CultureInfo"></see> to use as the current culture. </param>
      <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"></see> that provides a format context. </param>
      <param name="value">The <see cref="T:System.Object"></see> to convert. </param>
      <exception cref="T:System.NotSupportedException">The conversion cannot be performed. </exception>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AssemblyQualifiedTypeNameConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that represents the converted value.
            </returns>
      <param name="culture">A <see cref="T:System.Globalization.CultureInfo"></see>. If null is passed, the current culture is assumed. </param>
      <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"></see> that provides a format context. </param>
      <param name="destinationType">The <see cref="T:System.Type"></see> to convert the value parameter to. </param>
      <param name="value">The <see cref="T:System.Object"></see> to convert. </param>
      <exception cref="T:System.NotSupportedException">The conversion cannot be performed. </exception>
      <exception cref="T:System.ArgumentNullException">The destinationType parameter is null. </exception>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.AddExtensionContainerConfigurationCommand">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> that adds 
            an extension to the container. The command takes the extension type, and news
            up an instance of the extension at configuration time.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AddExtensionContainerConfigurationCommand.#ctor(System.Type)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.Configuration.AddExtensionContainerConfigurationCommand" /> which
            will add an extension of the type <paramref name="extensionType" /> to a container.
            </summary>
      <param name="extensionType">Type of the extension to add. This type must inherit
            from <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /></param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.AddExtensionContainerConfigurationCommand.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.Properties.Resources.ConversionNotSupported">
      <summary>
              Looks up a localized string similar to Can only convert to and from strings, not type {0}.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityTypeElement">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElement" /> class used to manage the contents
            of a &lt;type&gt; node in the configuration file.
            </summary>
      <remarks>
            Using the Type element in configuration can result in both type mappings
            and singletons being registered. If a name is specified, it is used
            for both the type mapping and singleton setting.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityTypeElement.GetConfigCommand">
      <summary>
            Get an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that will
            apply the configuration specified by this config element to the given
            container.
            </summary>
      <returns>The <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityTypeElement.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElement.Name">
      <summary>
            Name to use when registering this type. 
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElement.Type">
      <summary>
            Source type to configure in the container.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElement.MapTo">
      <summary>
            Destination type for type mapping.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityTypeElement.Lifetime">
      <summary>
            Sets the lifetime for the given type and name. Transient means 
            to create a new instance every type and is the default.
            Singleton means to return the same instance on every request.
            </summary>
      <remarks>
            When configuring a singleton, if both the type and mapTo attributes
            are specified, the SetSingleton call will be done on the type
            specified in the mapTo attribute. Otherwise it'll be done on the
            type specified in the Type attribute.
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement">
      <summary>
            This class provides a base class for configuration
            of a Unity container using user-installed container
            extensions.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement.DeserializeElement(System.Xml.XmlReader)">
      <summary>
            Read in the contents of this element from the <paramref name="reader" />.
            </summary>
      <param name="reader">
        <see cref="T:System.Xml.XmlReader" /> containing contents of element.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement.GetConfigurationCommand">
      <summary>
            Return an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> instance that, when
            executed, will configure a container with this element's state.
            </summary>
      <returns>The command object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement.Name">
      <summary>
            Name of this configuration element. Names must be unique.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionConfigurationElement.Type">
      <summary>
            Concrete type name for this configuration element.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.LifetimeStyle">
      <summary>
            The valid values to use for the configuration file's lifetime attribute.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.Configuration.LifetimeStyle.Transient">
      <summary>
            Create a new object every time (this is the default)
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.Configuration.LifetimeStyle.Singleton">
      <summary>
            Return the same instance every time
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElementCollection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElementCollection" /> that holds the collection of
            extension elements specified in the config file.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElementCollection.CreateNewElement">
      <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
      <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElementCollection.GetConfigCommand">
      <summary>
            Get an <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> object that will
            apply the configuration specified by this config element to the given
            container.
            </summary>
      <returns>The <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Configuration.UnityContainerExtensionElementCollection.Item(System.Int32)">
      <summary>
            Get or set the extension element stored at the given index.
            </summary>
      <param name="index">Index to get or set the element at.</param>
      <returns>The extension element.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand">
      <summary>
            A configuration command object that will register a pre-existing
            instance with the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand.#ctor(System.Type,System.Object,System.Boolean)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand" /> that, when executed
            will install the given instance into the container as a default value.
            </summary>
      <param name="instanceType">Type to use when registering the instance.</param>
      <param name="instance">Instance to put into the container.</param>
      <param name="containerControlsLifetime">bool value to pass to the RegisterInstance call.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand.#ctor(System.Type,System.String,System.Object,System.Boolean)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand" /> that, when executed
            will install the given instance into the container with the given name.
            </summary>
      <param name="instanceType">Type to use when registering the instance.</param>
      <param name="name">Name to register the instance with.</param>
      <param name="instance">Instance to put into the container.</param>
      <param name="containerControlsLifetime">bool value to pass to the RegisterInstance call.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.RegisterInstanceConfigurationCommand.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command against the given container.
            </summary>
      <remarks>
            Interface implementors will implement this method to
            apply configuration changes to the container.</remarks>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.Configuration.IContainerConfigurationCommand" /> that will set the
            given type as a singleton in the given container when executed.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand.#ctor(System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand" /> that will,
            when executed, set the given type as a singleton for the default.
            </summary>
      <param name="singletonType">Type to mark as singleton</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand.#ctor(System.Type,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand" /> that will,
            when executed, set the given type as a singleton for the given name.
            </summary>
      <param name="singletonType">Type to mark as singleton.</param>
      <param name="name">Name to use when configuring the container.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Configuration.SetSingletonConfigurationCommand.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Execute this command, applying the configuration to the given container.
            </summary>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to configure.</param>
    </member>
  </members>
</doc>